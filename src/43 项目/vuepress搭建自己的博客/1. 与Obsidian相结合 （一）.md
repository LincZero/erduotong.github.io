---
backlink: []
date: '2024-10-01'
isOriginal: true
outlink:
- /image/IMG-20241003 192402663-1. 与Obsidian相结合 （一）.png
- /image/IMG-20241003 192402814-1. 与Obsidian相结合 （一）.png
- /image/IMG-20241003 192403010-1. 与Obsidian相结合 （一）.png
tags:
- Blog
title: 1. 与Obsidian相结合 （一）
---
> [!tip] Obsidian
> Obsidian是一款笔记软件，你可以前往[官网](https://obsidian.md/)了解更多
## 0. 背景
我个人习惯在Obsidian进行写作，并且我个人很喜欢All In One，因此我很难接受再开启一个Obsidian的仓库来进行写作。
但是我的仓库也有很多不便于分享的其他内容，例如日记等，不能进行分享。
为了实现 自动化，有必要写个脚本，自动帮我过滤出可以被分享的文件。  
## 1. 语言选择
目前流行的脚本语言无外乎就两种，`Python`和`Javascript`。
考虑到`Javascript`对文件处理没`Python`那样优雅，并且没有类型系统（我不写Typescript，并且Ts太复杂了也不适合干这活），所以选择了Python
## 2. 结构梳理
先想想目标是什么:
- 简单易用
- 体验割裂少
### 单个文件
一般来说，博客主要是笔记构成的。如果需要声明是否分享，就需要一些地方来记录信息。

正好，Obsidian为我们提供了文档属性来记录一些信息。
![IMG-20241003 192402663-1. 与Obsidian相结合 （一）.png](/image/IMG-20241003 192402663-1. 与Obsidian相结合 （一）.png)
所以，我们就可以给每个笔记的文档属性中添加一个`share`的Bool属性，用来声明是否分享这个笔记。到时候，只需要点击就可以切换分享状态。
这样，我们就完成了对笔记文件的分享声明，完全满足了目标。

### 项目
但是，如果有一大堆笔记要分享，那么一个一个添加很累。如果有类似图片、白板、Excilidraw等不支持文档属性的也不方便声明。因此，我们再引入一个结构——项目。

每个文件夹都可以是一个项目，要声明一个项目的话，项目内就必须有一个`project.md`，在这个文件内可以处理该文件下所有的文件是否分享，并且还能放一些其他的信息。也就是相当于github上面的`README.md`
![IMG-20241003 192402814-1. 与Obsidian相结合 （一）.png](/image/IMG-20241003 192402814-1. 与Obsidian相结合 （一）.png)
`project.md`因为是笔记文件，也支持文档属性，因此，我们用相同的方式来使用文档属性![IMG-20241003 192403010-1. 与Obsidian相结合 （一）.png](/image/IMG-20241003 192403010-1. 与Obsidian相结合 （一）.png)
## 3. 仓库处理
> 你可以在我的博客[开源代码仓库](https://github.com/erduotong/erduotong.github.io/tree/main/scripts/vault_transform)找到这里的所有代码。
> 如果你不想看实现过程，你也可以直接跳到下一部分

### 需求
为了过滤，首先我们得处理一下链接，不然如果有一些图片，没设置`share`，到时候文章里面就不会有图片了。
因此，我们需要先处理所有的链接，再把所有和可分享文件有关的附件都分享出去（当然，笔记不属于附件，要是分享的话到时候整个库就会因为双链都被分享出去）

但是，Obsidian支持Wiki链接，并且Wiki链接的使用体验比较好。
所以我们还得多一步，Wiki链接转markdown链接。

接下来，就让我们开始写代码吧！

### 主程序
毕竟也不是什么大的程序，用不着太复杂的结构。
把程序拆分成几个函数，依次调用就行了。


### 预处理
Obsidian会有类似`.obsidian`的文件夹，用来存放配置文件，与我们的笔记无关。
所以，写一个预处理函数，把要删除的文件夹读进来，然后一个一个删除。

### 处理链接
这是最麻烦的一部分了，字符串的处理真的不算很简单。

首先，为了实现双链，我们必须给每个文件都做一下处理。既然每个文件都有双链，那就声明一个类来存储这些双链、标题数据。
并且，我们声明__str__，到时候方便打印。只需要```str(obj)```就可以获得输出的字符串了

接着，让我们跑一次遍历，给每个文件都放到我们的字典里面

然后，第二次遍历，处理一下markdown文件里面的链接
让我们来看一下逻辑。

首先，我们肯定得把内容拿出来，处理之后，再写回去

因为`mermaid`这种东西存在，所以代码块内部的东西肯定是不能动的。我们用一个函数把它们分开吧！

分开之后，就到了最丑的函数——替换链接了。

首先，我们来看看一般来说一个Obsidian的链接是长什么样的
```markdown
[[1. 与Obsidian相结合 (一)#0. 背景|123]]
```
可以看到，一共有文件名，标题，显示名称三部分组成。
让我们先把它们拆开来。

然后，我们需要找到`文件名`是属于哪个文件的，并且通过路径计算出相对路径。
不过在此之前，还是得先找到目前在处理哪个文件

如果是自己指向的是自己的话 （例如`[0. 背景](#0. 背景)`这种用法），那么也用不着处理，直接返回。

然后，让我们开找!
> [!note] 一些提示
> Obsidian中，如果有同名文件的话，不写路径就是在当前文件夹下，如果写了的话才是指定的。因此，优先从当前文件夹下开始找。

如果找到的话，那就好办了。通过Python的库计算一下就行，并且把双链记录好

找不到的话，那我们就认为是个相对路径，再次计算。
> [!tip] 
> 注意，相对路径直接拼接的话会出现类似`./abc/../e`的奇怪路径，所以要用normaPath处理一下

恭喜，Wiki链接已经全部转换成markdown链接了！并且，双链图谱也建立好了。

### 过滤文件
过滤文件就很简单了。
首先，跑一次递归，判断每个文件的分享可行性:

然后，直接根据双链计算下，没有覆盖到的就删了。

以及，因为我们使用`vuepress`，需要做一下yaml的转换，顺带做了吧!

## 4.结束
这样，我们的仓库就处理完成了。只保留了需要的内容。
接下来，内容就可以直接推送到公开仓库了。